package hashMap;


public class HashLinkedList<K,V>{
	/*
	 * Fields
	 */
	private HashNode<K,V> head;

	private Integer size;

	/*
	 * Constructor
	 */

	HashLinkedList(){
		head = null;
		size = 0;
	}


	/*
	 *Add (Hash)node at the front of the linked list
	 */
	public void add(K key, V value){
		HashNode<K,V> temp = head;
		while(head != null){
			if(head.getKey().equals(key)){
				head.setValue(value);
				return;
			}
			head = head.next;
		}
		size++;
		HashNode<K, V> newHashNode = new HashNode<>(key, value);
		newHashNode.next = temp;
		head = newHashNode;
	}

	/*
	 * Get Hash(node) by key
	 * returns the node with key
	 */

	public HashNode<K,V> getListNode(K key){
		HashNode<K,V> temp = head;
		while(temp != null){
			if(temp.getKey().equals(key)){
				return temp;
			}
			temp = temp.next;
		}
		return null;
	}


	/*
	 * Remove the head node of the list
	 * Note: Used by remove method and next method of hash table Iterator
	 */

	public HashNode<K,V> removeFirst(){
		HashNode<K,V> temp = head;
		if(head.next != null){
			head = head.next;
		}else{
			head = null;
		}
		return temp; 
	}

	/*
	 * Remove Node by key from linked list 
	 */

	public HashNode<K,V> remove(K key){
		if(head != null){
			HashNode<K,V> current = head;
			if(head.getKey().equals(key)){
				head = head.next;
				return current;
			}
			HashNode<K,V> previous = null;
			while( current != null && !current.getKey().equals(key)){
				previous = current;
				current = current.next;
			}
			
			if(current != null){
				previous.next = current.next;
			}
		}
		return null; // removing failed
	}



	/*
	 * Delete the whole linked list
	 */
	public void clear(){
		head = null;
		size = 0;
	}
	/*
	 * Check if the list is empty
	 */

	boolean isEmpty(){
		return size == 0? true:false;
	}

	int size(){
		return this.size;
	}

	//ADD YOUR HELPER  METHODS BELOW THIS


	//ADD YOUR HELPER METHODS ABOVE THIS


}
